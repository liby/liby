- 开始刷 NAPI-RS 的文档，之前写法多用的是 V1 的 API，V2 以后有了很多[变化](https://napi.rs/blog/announce-v2)
	- [在 JavaScript 和 Rust 之间进行 Object 转换的开销比其他 primitive types 要高](https://napi.rs/docs/concepts/values#:~:text=The,types)
	- Rust `fn` 中传递的 `#[napi(Object)]` 结构是从 JavaScript 对象克隆的。它上面的任何变化都不会反映到原本的 JavaScript 对象
	- 在 Rust 中传递 `BigInt` 的唯一方法是使用 `BigInt` 类型。但您可以返回 `BigInt`、`i64n`、`u64`、`i128`、`u128`。返回 `i64` 将被视为 `JavaScript` 数字，而不是 `BigInt`
	- Rust `fn` 不能接收 `i128`、`u128`、`u64`、`i64n` 作为参数的原因是，它们在将JavaScript `BigInt` 转换为自身时可能会失去精度。您可以使用 `BigInt::get_u128`、`BigInt::get_i128`... 以获取 `BigInt` 中的值。这些方法的返回值还指示是否丢失精度
	- 如果没有在 `struct ` 中定义 `#[napi(constructor)]`，并且您尝试在 JavaScript 中创建 `Class` 的实例(`new`)，则将抛出错误