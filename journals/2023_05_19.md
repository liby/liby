- [React re-renders guide: everything, all at once](https://www.developerway.com/posts/react-re-renders-guide)
	- **什么是 React 中的重渲染**：当 React 需要用一些新数据更新应用程序时，就会发生重渲染。这通常是用户与应用程序交互或通过异步请求或订阅模型接收外部数据的结果。
	- **必要和不必要的重渲染**：必要的重渲染是指源自变化的组件或直接使用新信息的组件的重渲染。不必要的重渲染是指由于错误或低效的应用程序架构而通过不同的重渲染机制在应用程序中传播的组件的重渲染。
	- **React 组件何时自我重渲染**：有四个原因会导致组件自我重渲染：状态变化、父组件（或子组件）重渲染、上下文变化和钩子变化。
	- **防止重渲染的方法**：包括使用组合、`React.memo`、`useMemo/useCallback` 来防止重渲染，以及改进列表的重渲染性能和防止由上下文引起的重渲染。
	- **防止重渲染的反模式**：在渲染函数中创建组件是一种反模式，可能是最大的性能杀手。每次重渲染时，React 都会重新挂载这个组件（即从头开始销毁并重新创建它），这比正常的重渲染要慢得多。
	- **改进重渲染性能的方法**：包括使用 `useMemo` 进行昂贵的计算，以避免在每次重渲染时进行昂贵的计算。
	- **改进列表的重渲染性能**：除了常规的重渲染规则和模式外，`key` 属性还可以影响 React 中列表的性能。
	- **防止由上下文引起的重渲染**：如果上下文提供者不是放在应用程序的根部，并且有可能因为其祖先的变化而重新渲染自己，那么其值应该被记忆化。
- [Announcing TypeScript 5.1 RC](https://devblogs.microsoft.com/typescript/announcing-typescript-5-1-rc/#linked-cursors-for-jsx-tags)
	- 1. **更简单的隐式返回**：对于返回 undefined 的函数，TypeScript 5.1 现在允许没有 return 语句。此外，如果一个函数没有返回表达式，并且被传递给期望返回 undefined 的函数，TypeScript 会为该函数的返回类型推断出 undefined。
	- 2. **获取器和设置器的无关类型**：TypeScript 5.1 现在允许 get 和 set 访问器属性具有完全无关的类型，只要它们有明确的类型注解。
	- 3. **JSX 元素和 JSX 标签类型之间的解耦类型检查**：TypeScript 5.1 现在查找名为 JSX.ElementType 的类型。ElementType 精确指定了可以用作 JSX 元素标签的有效内容。
	- 4. **命名空间 JSX 属性**：TypeScript 现在支持在使用 JSX 时使用命名空间属性名称。
	- 5. **在模块解析中咨询 typeRoots**：当 TypeScript 的指定模块查找策略无法解析路径时，它现在将相对于指定的 typeRoots 解析包。
	- 6. **将声明移动到现有文件**：除了将声明移动到新文件外，TypeScript 现在还提供了一个预览功能，用于将声明移动到现有文件。
	- 7. **JSX 标签的链接光标**：TypeScript 现在支持 JSX 标签名称的链接编辑。链接编辑（偶尔被称为“镜像光标”）允许编辑器同时自动编辑多个位置。
	- 8. **@param JSDoc 标签的片段补全**：在 TypeScript 和 JavaScript 文件中键入 @param 标签时，TypeScript 现在提供片段补全。这可以帮助减少在记录代码或在 JavaScript 中添加 JSDoc 类型时的一些键入和跳跃文本。
	- 此外，还进行了一些优化和破坏性更改。例如，TypeScript 5.1 现在需要最低运行时要求为 ES2020 和 Node.js 14.17。