- [《Write a Good CLI Program》](https://qiita.com/tigercosmos/items/678f39b1209e60843cc3) #read
	- 所谓的命令行程序就是指在终端中运行的程序，没有图形界面
	- 用 Rust 编写的现代版 `ls`：[exa](https://github.com/ogham/exa)
	- 通常我们会使用 `-h` 或 `--help` 命令以查看命令行程序的帮助信息
	- 添加参数最简单的方法是：`env::args().collect()`，但这种简单的实现使用起来很不方便：
		- 参数可能有默认值
		- 标识会交换位置
		- 选项会交换位置
		- `arg1` 可能会绑定 `arg2`
	- Clap 是一个全面、高效的 Rust 命令行参数解析器
		- 文章中使用的 clap 版本过旧，现行的 clap 版本已废弃 YAML API，参见[Deprecate Yaml API #3087](https://github.com/clap-rs/clap/issues/3087)
	- [dotenv_codegen](https://crates.io/crates/dotenv_codegen) 是一个带有宏的简单 *.env* 配置解析器
		- 使用 *.env* 编写应用配置，使用 dotenv 读取环境变量；
	- 使用 `env::var_os(key)` 可以调用系统中的环境变量
	- `panic!` 会导致程序直接退出，退出没有错误码，适合在脚本中使用
	- 函数返回 Result，可以根据是否为 Error 来决定后续操作
	- 可以为自定义 `Error` 实现 `fmt::Display trait`，方便格式化输出错误消息
	- 系统中有标准输出和标准错误
		- `println!()` 是标准输出，`eprintln!()` 是标准错误
	- 在程序有问题时使用非零退出码，以通知其他程序“我出错了”
		- ```
		  use std::process;
		  
		  fn main() {
		      process::exit(1);
		  }
		  ```
	- CLI 程序应该能解析参数和配置、读取环境变量、可以很好地处理错误、能够在标准输出和标准错误中输出相应的信息，并在执行失败时输出非零退出代码
- [《The Manifest Format》](https://doc.rust-lang.org/cargo/reference/manifest.html) #read
	- 在使用 `cargo` 命令创建的项目中，都会存在一个 *cargo.toml* 文件，这也就是所谓的 manifest
	- *cargo.toml* 是由多个部分配置组成的
		- `[package]` 部分的必需字段是 `name` 和 `version`
		  collapsed:: true
			- `name` 用来指代包的标识符，会作为 `lib` 和 `bin` 的默认名称
				- 名称只能使用字母数字字符或 `- ` 或 `_`
			- 关于 `version`
				- 在 `1.0.0` 以后，在 patch-level 版本中不增加任何新的公共 API (没有任何新的 pub 内容)。如果添加了任何新的发布结构、特征、字段、类型、函数、方法或任何其他内容，请始终递增次要版本
				- 使用包含三个数字部分的版本号，如 `1.0.0` 而不是  `1.0`
			- 如果 Cargo.toml 中不存在 `edition` 字段，那么为了具有向后兼容性，则假定为 2015 版本
			- `description` 字段必须是纯文本，不支持 Markdown
			- `keywords` 字段是描述此包的字符串数组
				- crates.io 最多有 5 个关键字。每个关键字必须是 ASCII 文本，以字母开头，并且只能包含字母、数字 `_` 或 `-`，并且最多包含 20 个字符
			- `categories` 字段是该包所属类别的字符串数组
				- crates.io最多有 5 个类别。每个类别都应与 [Category Slugs](https://crates.io/category_slugs) 中可用的字符串之一匹配，并且必须完全匹配
			- `workspace` 字段可用于配置此文件包将成为其成员的工作区
				- 如果未指定，这将被推断为文件系统中向上第一个带有 `[ workspace]` 字段的 *Cargo.toml*
				- 如果成员不在工作区根目录的子目录中，则设置此值非常有用
				- 一个 crate 不能既是一个工作区(包含 `[workspace]` )中根 crate，也不能是另一个工作区(包含 `package.workspace` )的成员 crates
			- `exclude` 和 `include` 字段可用于明确指定在打包要发布的项目时包含哪些文件，以及某些类型的更改跟踪
				- 可以运行 `cargo package --list` 以验证包中包含哪些文件
				- 如果这两个字段都未指定，则默认情况下将包括程序包根目录中的所有文件，以下列出的排除项除外
					- 如果没有指定 include，则以下文件将被排除：
						- 如果 package 不在 git 存储库中，那么所有以 `.` 开头的隐藏文件都将被跳过
						- 如果 package 在 git 存储库中，那么任何被存储库和全局 git 配置的 gitignore 规则忽略的文件都将被跳过
					- 无论指定的是 `exclude` 和 `include`，始终排除以下文件：
						- 将跳过任何子 package(包含 *Cargo.toml* 文件的任何子目录)
						- 将跳过 package 的根目录中名为 *target* 的目录
					- 始终包含以下文件：
						- package 本身的 Cargo.toml 文件始终包含在内，它不需要列在Include中。
						- [如果 package 包含 binary 或者 example target，则会自动包含最小化的 *Cargo.lock*](https://doc.rust-lang.org/cargo/commands/cargo-package.html)
						- 如果指定了 `license-file` ，则始终包含该文件
				- 这些选项是互斥的；设置include将覆盖一个 exclude；如果您需要排除一组include文件，请使用 `!`
				- patterns 应该是 gitignore-style patterns
		- `[profile.*]` 部分提供了一种自定义编译器设置（例如优化和调试设置）的方法
- [《Cargo environment variables》](https://doc.rust-lang.org/cargo/reference/environment-variables.html) #read
	- 环境变量可以用来和 `rustc` 以及 Cargo 进行通信
	- 可以在代码中通过 `env!` 宏或者在构建脚本中设置环境变量，这样可以控制构建行为
- [《Rust API Guidelines: Documentation》](https://rust-lang.github.io/api-guidelines/documentation.html) #read
	- crate 级别的文档应该是全面详细的，且包含使用示例
	- 文档中的实例应该使用 ? 处理错误，而非 `try!` 或者 `unwrap`
	- 函数的文档中应该包括：函数功能描述、返回的错误（`# Errors`）、Panic 情况（`# Panics`）以及一些安全使用的提示（`# Safty`，比如 `std::ptr::read` 这种 `unsafe` 函数）
	- 文档中提到的类型应该关联到对应的文档
	- *Cargo.toml* 中应该包含所有常用的元信息
	- crate 要设置正确的 `#![doc(html_root_url = "https://docs.rs/CRATE/MAJOR.MINOR.PATCH")]`
		- 版本号要和 *Cargo.toml* 中的 `version` 保持一致；
	- 在发布日志（Release notes）中记录所有重大变更
	- 可以通过 `#[doc(hidden)]` 将一些没什么帮助的实现细节（如私有类型关联的方法实现等）从生成的文档中隐藏起来